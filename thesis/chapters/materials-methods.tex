\chapter{Materials \& Methods}\label{ch:matmeth}

\section{Synthetic signals}

\section{Physiological signals}\label{sec:physsig}

\subsection{Research group}\label{subsec:researchgr}
The data set with the physiological signals come from the study conducted for the \textit{AUTOMATIC} project conducted at Wrocaw University of Wroclaw and Technology (WUST). 
It consists of 37 young healthy volunteers (21 males, 16 males, median age: 22 years, range 18-31 years). 
Everyone was instructed not to consume alcohol and caffeine 12 hours before the study and declared to be free of medication. 
Measurements were taken under the supervision of a profesional physician and were approved by the Comission of Bioethics (KB-179/2023/N) \citep{Uryga_2024}.

\subsection{Data acquisition}\label{subsec:dataacq}
For the BRS estimation mentioned in section \ref{sec:baroreflex}, two raw signals were used among others for the calculations:
\begin{itemize}
  \item ABP recorded noninvasively using a photoplethysmograph (Finometer MIDI)
  \item ETCO$_{2}$ recorded using a capnograph
\end{itemize}

Measurements were made at room temperature with minimal external stimuli as in Figure \ref{fig:experiment-setup} and were carried out in four stages lasting 5 minutes each and performed one after another. 
In stage 1 subjects were breathing at their resting rate, and in stages 2,3,4 they were performing controlled breathing guided by metromone, respectively, at rates 6,10 and 15 breaths per minute (bpm).
Each epoch was performed with a 5 minute long break, and the signals were sampled at $f_s=200 Hz$.
All the data was gathered into separate \textit{csv} format files, for each patient and breathing stage.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{figs/materials-methods/physiological/experiment_setup.jpg}
    \caption{The experiment setup}
    \label{fig:experiment-setup}
\end{figure}

\subsection{Preprocessing}\label{sec:preprocessing}
Minimal preprocessing was already performed on the received data, which included:
\begin{enumerate}
    \item \textbf{Filtering:}
    \begin{itemize}
        \item A low-pass filter was utilized with cut-off frequency of $40$ Hz to remove high-frequency artefacts
    \end{itemize}

    \item \textbf{Abnormal Peak (Outlier) Detection:}
    \begin{itemize}
        \item Outliers were detected by calculating the signal's first derivative
        \item The derivative was analyzed within a specified window size of $3-11$ samples per window
        \item A peak was classified as an outlier if it exceeded two times the standard deviation of the signal derivative within widnow
    \end{itemize}

    \item \textbf{Outlier Replacement and Missing Value Handling:}
    \begin{itemize}
        \item both outliers and missing values were replaced with a linear interpolation
    \end{itemize}
\end{enumerate}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figs/materials-methods/physiological/Preprocessed raw signals.png}
    \caption{Sample of preprocessed raw signals for breathing at rest}
    \label{fig:raw-data}
\end{figure}

\subsection{Signals Processing}\label{sec:processing}
Firstly data is loaded using \textit{BaroreflexDataLoader} that is child of \textit{DataLoader} class.
\begin{minted}{python}
class BaroreflexDataLoader(DataLoader):
  @property
  @override
  def _data_directory(self) -> Path:
      return BREATHING_DATA_DIRECTORY_PATH

  @property
  @override
  def _csv_columns(self) -> dict[str, str]:
      return {'abp': SignalColumns.ABP, 'etco2': SignalColumns.ETCO2}

  @override
  def load_single_patient_raw_data(self, patient_directory: Path) -> PatientData:
      return {
          'id': self._get_patient_id(patient_directory),
          CB_FILE_TYPE.B6: self.load_single_cb_csv_file(patient_directory / CB_FILE_TYPE.B6.csv),
          CB_FILE_TYPE.B10: self.load_single_cb_csv_file(patient_directory / CB_FILE_TYPE.B10.csv),
          CB_FILE_TYPE.B15: self.load_single_cb_csv_file(patient_directory / CB_FILE_TYPE.B15.csv),
          CB_FILE_TYPE.BASELINE: self.load_single_cb_csv_file(patient_directory / CB_FILE_TYPE.BASELINE.csv),
      }
\end{minted}

The inherited \textit{load\_single\_patient\_raw\_data()} method handles the whole process of fetching the data from all the \textit{csv} files from declared \textit{\_data\_directory} using \textit{load\_single\_patient\_raw\_data()}.
Resulting list of \textit{PatientData} with loaded ABP and ETCO$_2$ columns for each breathing stage is ready for the processing with usage of \textit{BaroreflexDataProcessor}.

Similarly as \textit{BaroreflexDataLoader}, this class inherits methods from \textit{DataProcessor} abstract class, that provides ready method for processing signals for all of the subjects and breathing stages for given \textit{\_process\_signle\_cb()} implementation.

\begin{minted}{python}
class BaroreflexDataProcessor(DataProcessor):
    @override
    def _process_single_cb(self, raw_data: ArrayDataDict) -> ArrayDataDict:
        abp = raw_data.get('abp')
        etco2 = raw_data.get('etco2')
        if abp is None or etco2 is None:
            raise ValueError

        peaks = get_peaks(abp)
        sap = get_sap(abp, peaks)
        hp = get_hp(peaks)
        etco2_adjusted = adjust_etco2(etco2, peaks)
        return {'sap': sap, 'hp': hp, 'etco2': etco2_adjusted}
\end{minted}

The end goal of the \textit{DataProcessor} is to produce the final signals for TE alghorithms that are used for the BRS estimation - SAP, HP, ETCO$_2$, using abstracted \textit{process()} method.
The crucial obstacle at this step is to find realiable way of peaks estimation in the signal.
For this purpose \textit{neurokit2 python} package is leveraged, since it has a collection of ready to use professional alghorithms for physiological data processing \cite{neurokit2}.

\begin{minted}{python}
_DEFAULT_MIN_DELAY = 0.3
_DEFAULT_FIND_PEAKS_METHOD = 'elgendi'


class PeaksMode(Enum):
    UP = 'up'
    DOWN = 'down'
    BOTH = 'both'


def get_peaks(
    signal: NDArray[np.floating],
    mode: PeaksMode = PeaksMode.UP,
    sampling_rate: int = SAMPLING_FREQUENCY,
    method: str = _DEFAULT_FIND_PEAKS_METHOD,
    mindelay: float = _DEFAULT_MIN_DELAY,
) -> NDArray[np.integer]:
    filled_signal = nk.signal_fillmissing(signal)
    cleaned_signal = cast(NDArray[np.floating], nk.ppg_clean(filled_signal, sampling_rate=sampling_rate, method=method))

    peaks_up: NDArray[np.integer] | None = None
    peaks_down: NDArray[np.integer] | None = None

    if mode in (PeaksMode.UP, PeaksMode.BOTH):
        peaks_up = _find_peaks(
            cleaned_signal,
            sampling_rate=sampling_rate,
            method=method,
            mindelay=mindelay,
        )
    if mode in (PeaksMode.DOWN, PeaksMode.BOTH):
        peaks_down = _find_peaks(
            cleaned_signal * -1,
            sampling_rate=sampling_rate,
            method=method,
            mindelay=mindelay,
        )

    if peaks_up is not None and peaks_down is not None:
        return np.sort(np.concatenate((peaks_up, peaks_down)))
    if peaks_up is not None:
        return peaks_up
    return cast(NDArray[np.integer], peaks_down)


def _find_peaks(
    cleaned_signal: NDArray[np.floating],
    sampling_rate: int = SAMPLING_FREQUENCY,
    method: str = _DEFAULT_FIND_PEAKS_METHOD,
    mindelay: float = _DEFAULT_MIN_DELAY,
) -> NDArray[np.integer]:
    peaks = nk.ppg_findpeaks(
        cleaned_signal,
        sampling_rate=sampling_rate,
        method=method,
        mindelay=mindelay,
    )['PPG_Peaks']
    return cast(NDArray[np.integer], peaks)
\end{minted}

%TODO: Teoretycznie jest to do PPG sygnałów, ale czy musze opisac czemu dla abp tez stosuje?
There are 3 functions in total used from \textit{neurokit2} to get signal peaks in form of array of indecies at which peaks occur, using \textit{"elgendi"} peak detection method by a default \cite{elgendi2013systolic}.
\begin{enumerate}
  \item \textit{nk.signal\_fillmissing()} - fills missing values in signal (what does nothing for this study use case, since missing values were already filled at the preprocessing step).
  \item \textit{nk.ppg\_clean()} - performs low-pass butterworth filtering
  \item \textit{nk.ppg\_findpeaks()} - squares positive values of the cleaned signal to amplify the systolic peak energy, then applies a dynamic threshold derived from short- and long-term moving averages to identify segments containing a potential beat. 
    Within these high-energy segments, the most prominent local maximum in the original signal is selected as the final systolic peak.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figs/materials-methods/physiological/Cleaned ABP signal.png}
    \caption{Cleaned ABP signal using \textit{nk.ppg\_clean()}}
    \label{fig:nk-cleaned_signal}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figs/materials-methods/physiological/ABP signal with detected peaks.png}
    \caption{ABP signal with detected peaks using \textit{nk.ppg\_findpeaks()}}
    \label{fig:nk-found_peaks}
\end{figure}

Having found peaks in the ABP signal the SAP, HP, and adjusted ETCO$_2$ for each $i$-th $peak$ - which represent indecies in the ABP where they happen, can be calculated using the following formulas:

\begin{equation}
  \text{peaks} = [peak_0, peak_1, \dots, peak_i, \dots]
\end{equation}
\begin{equation}\label{eq:sap_from_abp}
  \text{SAP}_i = \text{ABP}_{peak_i} \text{ } [mmHg]
\end{equation}
\begin{equation}\label{eq:rr_from_abp}
  \text{HP}_i = \text{RR}_i = \frac{peak_i - peak_{i-1}}{f_s} \cdot 1000 \text{ } [ms]
\end{equation}
\begin{equation}
  \text{ETCO}_2_i = \text{mean}(\text{ETCO}_2_{peak_{i-1}}, \dots, \text{ETCO}_2_{peak_i}) 
\end{equation}

\begin{minted}{python}
def get_hp(peaks: NDArray[np.integer], sampling_rate: int = SAMPLING_FREQUENCY) -> NDArray[np.floating]:
    sampling_period = 1 / sampling_rate * 1000
    return np.diff(peaks) * sampling_period


def get_sap(abp: NDArray[np.floating], peaks: NDArray[np.integer]) -> NDArray[np.floating]:
    return np.array([abp[peak] for peak in peaks])[1:]  # skip first peak to match length of hp


def adjust_etco2(etco2: NDArray[np.floating], peaks: NDArray[np.integer]) -> NDArray[np.floating]:
    if len(etco2) < peaks[-1]:
        raise ValueError('ETCO_2 signal is shorter than peaks!')
    return np.array([np.mean(etco2[peak - 1 : peak]) for i, peak in enumerate(peaks) if i != 0])
\end{minted}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figs/materials-methods/physiological/Preprocessed raw signals, with annotations.png}
    \caption{Processing signals with \textit{BaroreflexDataProcessor}}
    \label{fig:processing_signals}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figs/materials-methods/physiological/processed signals.png}
    \caption{Processed signals with \textit{BaroreflexDataProcessor}}
    \label{fig:processed_signals}
\end{figure}


\section{TE and DVP Implementation}\label{sec:te_dvp-implementation}


